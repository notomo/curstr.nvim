
call themis#option('recursive', 1)

if exists('$CURSTR_ENV')
    let g:python3_host_prog = expand('<sfile>:h:h') . '/curstr_env/bin/python3'
endif
runtime! plugin/rplugin.vim

let s:packpath = &packpath
let s:root = getcwd()
let s:test_data_path = 'test/autoload/_test_data/'
let s:test_data_dir = getcwd() .. '/' .. s:test_data_path

call curstr#test#start_testing()

function! CurstrTestHelper() abort
    let helper = {
        \ 'assert': s:assert(),
        \ 'test_data_path': s:test_data_path,
    \ }

    function! helper.before_each() abort
        execute 'cd' s:root
        call mkdir(s:test_data_dir, 'p')

        call themis#log('')
    endfunction

    function! helper.after_each() abort
        silent! %bwipeout!
        call curstr#custom#clean()
        execute 'cd' s:root
        let &packpath = s:packpath
        call delete(s:test_data_dir, 'rf')
    endfunction

    function! helper.suite(name) abort
        let suite = themis#suite(a:name)
        let suite.before_each = self.before_each
        let suite.after_each = self.after_each
        return suite
    endfunction

    function! helper.open_new_file(path, ...) abort
        let content = len(a:000) > 0 ? a:000[0] : []
        call self.new_file(a:path, content)
        execute 'edit' s:test_data_dir . a:path
    endfunction

    function! helper.new_file(path, ...) abort
        call system(['touch', s:test_data_dir . a:path])
        if len(a:000) > 0
            call writefile(a:000[0], s:test_data_dir . a:path)
        endif
    endfunction

    function! helper.new_directory(path) abort
        call mkdir(s:test_data_dir . a:path, 'p')
    endfunction

    function! helper.buffer(...) abort
        setlocal buftype=nofile
        call nvim_buf_set_lines(bufnr('%'), 0, -1, v:false, a:000)
    endfunction

    function! helper.add_packpath(path) abort
        execute 'set packpath^=' . fnamemodify(s:test_data_dir . a:path, ':p')
    endfunction

    function! helper.cd_to_test_data() abort
        execute 'cd' s:test_data_dir
    endfunction

    function! helper.search(pattern) abort
        let result = search(a:pattern)
        if result == 0
            let message = printf('%s not found', a:pattern)
            call self.assert.fail(message)
        endif
        return result
    endfunction

    return helper
endfunction

function! s:assert() abort
    let assert = themis#helper('assert')

    function! assert.file_name(expected) abort
        let actual = fnamemodify(bufname('%'), ':t')
        let message = printf('file name should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.cursor_word(expected) abort
        let actual = expand('<cword>')
        let message = printf('cursor word should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.current_line(expected) abort
        let actual = getline(line('.'))
        let message = printf('current line should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.current_buffer(expected) abort
        let actual = expand('%:.')
        let message = printf('current buffer should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.path(expected) abort
        let actual = fnamemodify(expand('%:p'), ':.')
        let message = printf('file path should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.not_path(expected) abort
        let actual = fnamemodify(expand('%:p'), ':.')
        let message = printf('file path should not be %s', a:expected)
        call self.not_equals(actual, a:expected, message)
    endfunction

    function! assert.line_number(expected) abort
        let actual = line('.')
        let message = printf('line_number should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.column_number(expected) abort
        let actual = col('.')
        let message = printf('column number should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.window_count(expected) abort
        let actual = tabpagewinnr(tabpagenr(), '$')
        let message = printf('window count must be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.tab_count(expected) abort
        let actual = tabpagenr('$')
        let message = printf('tab count should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.position(expected) abort
        let actual = getpos('.')
        let message = printf('position should be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    function! assert.current_dir(expected) abort
        let actual = getcwd()[len(s:test_data_dir):]
        let message = printf('current dir be %s, but actual: %s', a:expected, actual)
        call self.equals(actual, a:expected, message)
    endfunction

    return assert
endfunction
